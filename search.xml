<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="2021/09/24/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A/"/>
      <url>2021/09/24/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<p>数字图像处理作业</p><p><img src="/.io//Node\myblog\myblog\source\数字图像处理作业\5.jpg" alt="5"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/09/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/"/>
      <url>2021/09/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<p>计算机组成原理作业:</p><p><img src="/.io//Users\dd\Desktop\1.png" alt="1"><img src="/.io//Users\dd\Desktop\2.png" alt="2"><img src="/.io//Users\dd\Desktop\3.png" alt="3"><img src="/.io//Users\dd\Desktop\4.jpg" alt="4"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/03/21/C++/"/>
      <url>2021/03/21/C++/</url>
      
        <content type="html"><![CDATA[<p>C++ STL：</p><p>1.Stack(容器适配器):</p><p>​           &lt;1&gt;可用的顺序容器：vector,list,deque（默认）</p><p>​            &lt;2&gt;覆盖默认容器类型： stack&lt;int,vector<int>&gt;stk;</int></p><p>​            &lt;3&gt;stack<int> s;</int></p><p>​                   s.pop(); //删除栈顶元素，但是不返回其值。</p><p>​                    s.top(); //返回栈顶元素，但是不删除此元素。</p><p>2.Queue(容器适配器)：</p><p>​                        &lt;1&gt;可用的顺序容器：list,deque（默认）。</p><p>​                         &lt;2&gt;queue<int> q;</int></p><p>​                                q.front();  //返回队首元素的值，但不删除该元素</p><p>​                                 q.back();   //返回队尾元素的值，但不删除该元素。</p><p>​                          &lt;3&gt;priority_queue:</p><p>​                                              priority_queue<int> p;</int></p><p>​                                              p.top(); // 返回具有最高优先级的元素值，但是不删除该元素。</p><p>​                                               p.push 插入元素到队尾 (并排序);</p><p>​                                               优先队列具有队列的所有特性，包括基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的.</p><p>3.Vector(容器)：</p><p>​                         &lt;1&gt;push_back 在数组的最后添加一个数据。</p><p>​                          &lt;2&gt;pop_back 去掉数组的最后一个数据.</p><p>​                           &lt;3&gt;begin 得到数组头的指针.</p><p>​                           &lt;4&gt;end 得到数组的最后一个单元+1的指针.</p><p>​                            &lt;5&gt;resize 改变当前使用数据的大小，如果它比当前使用的大，者填充默认值</p><p>​                             &lt;6&gt;erase 删除指针指向的数据项.</p><p>​                              &lt;7&gt;clear 清空当前的vector</p><p>​                              &lt;8&gt;swap 与另一个vector交换数据</p><p>​                               &lt;9&gt;empty 判断vector是否为空</p><p>​                               &lt;10&gt;vector<int>::iterator it; //迭代器的生成。</int></p><p>​                                        for(it=obj.begin();it!=obj.end();it++){</p><p>​                                                           cout&lt;&lt;*it&lt;&lt;” “;</p><p>​                                                   }</p><p>​                                </p><p>4.deque(容器)：双向队列。</p><p>deq[ ]：用来访问双向队列中单个的元素。</p><p>deq.front()：返回第一个元素的引用。<br>deq.back()：返回最后一个元素的引用。<br>deq.push_front(x)：把元素x插入到双向队列的头部。<br>deq.pop_front()：弹出双向队列的第一个元素。<br>deq.push_back(x)：把元素x插入到双向队列的尾部。<br>deq.pop_back()：弹出双向队列的最后一个元素。</p><p>5.list(容器)：双向链表</p><p> &lt;1&gt; Lst1.insert() 插入一个元素到list中 </p><p>&lt;2&gt;Lst1.assign() 给list赋值 </p><p>&lt;3&gt;Lst1.back() 返回最后一个元素 </p><p>​        Lst1.begin() 返回指向第一个元素的迭代器<br>​        Lst1.clear() 删除所有元素<br>​        Lst1.empty() 如果list是空的则返回true<br>​        Lst1.end() 返回末尾的迭代器<br>​        Lst1.erase() 删除一个元素<br>​        Lst1.front() 返回第一个元素</p><pre><code>     Lst1.merge() 合并两个list </code></pre><p>​        Lst1.pop_back() 删除最后一个元素<br>​        Lst1.pop_front() 删除第一个元素<br>​        Lst1.push_back() 在list的末尾添加一个元素<br>​        Lst1.push_front() 在list的头部添加一个元素 </p><pre><code>    Lst1.size() 返回list中的元素个数     Lst1.sort() 给list排序     Lst1.splice() 合并两个list     Lst1.swap() 交换两个list     Lst1.unique() 删除list中相邻重复的元素 </code></pre><p>5.map/mutilmaps:(键值对)</p><p>​                        &lt;1&gt;unordered_map 容器和 map 容器仅有一点不同，即 map 容器中存储的数据是有序的，而 unordered_map 容器中是无序的。类似于unordered——set容器和set容器的区别。</p><p>​                         &lt;2&gt;map中的元素是自动按Key升序排序，所以不能对map用sort函数；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="number">3</span>&gt;begin()         返回指向<span class="built_in">map</span>头部的迭代器</span><br><span class="line"></span><br><span class="line">clear(）        删除所有元素</span><br><span class="line"></span><br><span class="line">count()         返回指定元素出现的次数</span><br><span class="line"></span><br><span class="line">empty()         如果<span class="built_in">map</span>为空则返回<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">end()           返回指向<span class="built_in">map</span>末尾的迭代器</span><br><span class="line"></span><br><span class="line">equal_range()   返回特殊条目的迭代器对</span><br><span class="line"></span><br><span class="line">erase()         删除一个元素</span><br><span class="line"></span><br><span class="line">find()          查找一个元素</span><br><span class="line"></span><br><span class="line">get_allocator() 返回<span class="built_in">map</span>的配置器</span><br><span class="line"></span><br><span class="line">insert()        插入元素</span><br><span class="line"></span><br><span class="line">key_comp()      返回比较元素key的函数</span><br><span class="line"></span><br><span class="line">lower_bound()   返回键值&gt;=给定元素的第一个位置</span><br><span class="line"></span><br><span class="line">max_size()      返回可以容纳的最大元素个数</span><br><span class="line"></span><br><span class="line">rbegin()        返回一个指向<span class="built_in">map</span>尾部的逆向迭代器</span><br><span class="line"></span><br><span class="line">rend()          返回一个指向<span class="built_in">map</span>头部的逆向迭代器</span><br><span class="line"></span><br><span class="line">size()          返回<span class="built_in">map</span>中元素的个数</span><br><span class="line"></span><br><span class="line">swap()           交换两个<span class="built_in">map</span></span><br><span class="line"></span><br><span class="line">upper_bound()    返回键值&gt;给定元素的第一个位置</span><br><span class="line"></span><br><span class="line">value_comp()     返回比较元素value的函数</span><br></pre></td></tr></table></figure><p>6.Set（容器）：</p><p>   1.begin()–返回指向第一个元素的迭代器</p><ol start="2"><li>clear()–清除所有元素</li><li>count()–返回某个值元素的个数</li><li>empty()–如果集合为空，返回true</li><li>end()–返回指向最后一个元素的迭代器</li><li>equal_range()–返回集合中与给定值相等的上下限的两个迭代器</li><li>erase()–删除集合中的元素<br>a.erase(val);//删除键值val</li><li>find()–返回一个指向被查找到元素的迭代器</li><li>get_allocator()–返回集合的分配器</li><li>insert()–在集合中插入元素<br>a.insert(pos,val);//在pos位置添加值val，位置不重要，因为插入后，set会自动排序</li><li>lower_bound()–返回指向大于（或等于）某值的第一个元素的迭代器</li><li>key_comp()–返回一个用于元素间值比较的函数</li><li>max_size()–返回集合能容纳的元素的最大限值<br>例如set<int> a; a.max_size返回的就是整型的上界214748364</int></li><li>rbegin()–返回指向集合中最后一个元素的反向迭代器</li><li>rend()–返回指向集合中第一个元素的反向迭代器</li><li>size()–集合中元素的数目</li><li>swap()–交换两个集合变量</li><li>upper_bound()–返回大于某个值元素的迭代器</li><li>value_comp()–返回一个用于比较元素间的值的函数。</li></ol><p>​                                   </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="2021/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>2021/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p>1.IP数据报的格式：版本包括IPV4和IPV6；总长度包括首部长度和数据部分长度。</p><p> 首部长度占4位，最大值位15，值为1表示的是一个32位字的长度，也就是4个字节，因为首部长度为20个字节，因此该值最小为5，如果可选字段的长度不是4字节的整数倍，就用尾部的填充部分来填充。</p><p>2.IP数据报=首部+数据部分</p><p>3.生存时间：TTL,目的是防止无法交付的数据报在互联网中不断的兜圈子。以路由器跳数为单位，每经过一个路由器，在转发之前就把跳数减为1，当TTL减为0时就会丢弃这个数据报，因为数据报在因特网中最大经过的路由器是255。</p><p>4.协议：指出携带的数据应该上交给那个协议进行处理。</p><p>5.首部校验和：因为数据报每经过一个路由器，都要重新计算校验和，因此校验和不包括数据部分可以减少计算的工作量。</p><p>6.标识：在数据报长度过长而发生分片的情况下，相同的数据报的不同分片具有相同的标识。</p><p>7.标志：占3位，目前仅仅2位有意义，最低位记为MF，MF=1表示后面还有分片的数据报，MF=0表示这是若干数据报中的最后一个；中间的一位位DF，意味着不能分片，只有当DF=0时才允许分片。</p><p>如图IP数据报格式：！<a href="IP%E6%8A%A5.png">IP数据报格式图</a></p><p>8.TCP三次握手：如图所示！<a href="TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg">TCP三次握手</a></p><p>​                         SYN：同步SYN(SYNchronization),在连接建立使用来同步序号。SYN置1表示                                    这是一个连接请求或连接接受请求。</p><p>​                        ACK：确认ACK(ACKnowledgment),仅当ACK=1时确认号字段才有效。TCP规                                    定，在连接建立后所有的报文段都必须把ACK置1。</p><p>​                        seq: 序号。</p><p>​                        ack: 确认号。</p><p>9.TCP四次挥手：如图所示！<a href="TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg">TCP四次挥手</a></p><p>​                             数据传输结束后，通信的双方都可以释放连接。图上所示的为A的应用进程先                                                 向其TCP发出连接释放报文段，但是A结束TCP连接的时间要比B晚一些。</p><p>​                             FIN: 终止FINs,用来释放一个连接。当FIN等于1时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。</p><p>ACK: 确认ACK(ACKnowledgment),仅当ACK=1时确认号字段才有效。TCP规定，在连接建立后所有的报文段都必须把ACK置1。</p><p>seq: 序号。</p><p>ack: 确认号。</p><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p><ul><li>A 发送连接释放报文，FIN=1。</li><li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li><li>当 B 不再需要连接时，发送连接释放报文，FIN=1。</li><li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li><li>B 收到 A 的确认后释放连接。</li></ul><p>##TCP四次挥手的原因##：</p><p><strong>CLOSE-WAIT</strong></p><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><p><strong>TIME-WAIT</strong></p><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。</p><p>为什么A在TIME-WAIT状态必须等待2MSL的时间呢？</p><p>这么做有两个理由：</p><ul><li>为了保证A发送的最后一个ACK报文段能够到达B。<br>A发送的这个ACK报文段有可能丢失，如果 B 没收到 A 发送来的确认报文，那么A就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li><li>防止“已经失效的连接请求报文段”出现在本链接中。<br>A在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接的时间内所产生的所有报文段都从网络中消失。这样下一个新的连接中就不会出现这种旧的连接请求报文段。</li></ul><p><strong>为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</strong></p><p>这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的连接请求后，它可以把ACK和SYN(ACK起应答作用，而SYN起同步作用)放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，<strong>它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，</strong>所以你可能未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</p><p>10.UDP【用户数据报协议】：</p><p>​                               在TCP/IP模型中，UDP为<a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%B1%82">网络层</a>以上和<a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E5%B1%82">应用层</a>以下提供了一个简单的接口。UDP只提供数据的不可靠传递，它一旦把应用程序发给网络层的数据发送出去，就不保留数据备份（所以UDP有时候也被认为是不可靠的数据报协议）。UDP在IP数据报的头部仅仅加入了复用和数据校验（字段）</p><p>11.TCP和UDP的区别和联系：</p><p>​                               1.TCP面向连接，传输数据之前要需要建立会话。UDP是无连接的。</p><p>​                               2.TCP提供可靠传输，保证数据不丢包、不重复且按顺序到达；UDP只尽努力交付，不保证可靠交付</p><p>​                              3.TCP提供了拥塞控制；UDP不提供</p><p>​                               4.TCP是面向字节流的；UDP面向报文。</p><p>​                               5.TCP只支持点到点通信；UDP支持一对一、一对多、多对多的交互通信。</p><p>​                               6.TCP首部开销大20字节，UDP首部开销小8字节。                           </p><p>12.UDP首部格式：如图！<a href="UDP%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.jpg">UDP首部格式</a></p><p>13.TFTP：简单文件传输协议，该协议在69端口上使用UDP服务。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/03/15/markdown/"/>
      <url>2021/03/15/markdown/</url>
      
        <content type="html"><![CDATA[<p>1.Markdown代码编写语法：</p><p>​             &lt;1&gt;行内代码使用’ ‘来标记：例如函数’scanf()’里面的函数名字就是这样标记的。</p><p>​            &lt;2&gt;多行代码：在需要高亮的代码的前一行及后一行使用反引号```(~键)，同时在第一行反引号后面，输入代码块使用的语言，实现代码高亮。</p><p>​            &lt;3&gt;缩进式插入多行代码：缩进插入前方必须有空行；缩进4个空格或者一个制表符。</p><p>2.快捷键：</p><p>​               加粗： Ctrl+B</p><p>​                插入链接： Ctrl+L</p><p>​                插入代码：Ctrl+K</p><p>​                插入图片：Ctrl+G</p><p>​                横线：Ctrl+R</p><p>​                 撤销：Ctrl+Z</p><p>3.标题：分为六级，一级对应一个#，二级对应2个#。。。。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/03/15/Antsword/"/>
      <url>2021/03/15/Antsword/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/03/14/Hexo/"/>
      <url>2021/03/14/Hexo/</url>
      
        <content type="html"><![CDATA[<p>1.hexo clean :清除缓存文件</p><p>2.hexo g:生成博客文件</p><p>3.hexo s:启动本地服务器通过，localhost:4000访问</p><p>4.hexo d:发布到服务器</p><p>5.hexo  g  -d :组合命令，生成文件并发表</p><p>6.hexo n   “articalname” :创建新的文章</p><p>7.<a href="xxxx/%E5%9B%BE%E7%89%87%E5%90%8D.jpg">你想输入的替代文字</a>：插入图片</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/03/14/%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/03/14/%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>1.常见的协议和端口号</p><p>​            DHCP协议【动态主机设置协议，用于自动分配IP地址】：67【服务器的端口号，基于UDP】；68【客户机的端口号】</p><p>​              HTTPS：443【基于TCP；基于UDP】【https=http+ssl,更安全】</p><p>​              tomcat: 8080</p><p>​              mongdb:27017</p><p>​              mysql:3306</p><p>​              Oracle:1521</p><p>​              SMB：445</p><p>​               SSH:22</p><p>​               FTP【文件传输协议】:21</p><p>​               Telnet【远程登陆协议】：23</p><p>​                SMTP【简单邮件传输协议】：25</p><p>​                 DNS【域名解析服务】：53</p><p>2.Windows中ping命令发送4个ICMP回送请求，每一个32字节的数据；Linux中发送次数不限，每一个64字节的数据。</p><p>3.端口是各种程序为了接收和发送数据而打开的窗户；分为UDP和TCP端口，每一种端口范围均为1~65535</p><p>4.FTP匿名登录的弱口令：</p><p>​                 &lt;1&gt;用户名：annoymous   密码： Email或者为空  </p><p>​                  &lt;2&gt;FTP       FTP或者为空</p><p>​                   &lt;3&gt;USER     pass</p><ol start="5"><li><p>OSI的体系结构（7层）：物理层–》数据链路层–》网络层–》传输层–》会话层–》表示层–》应用层</p></li><li><p>TCP/IP的体系结构：网络接口层–》网际层【IP】–》运输层【TCP或者UDP】–》应用层【各种应用层协议如FTP,SSH,SMTP等】</p></li><li><p>物理层对应的协议：IEEE802.3（中继器，集线器，网关）</p></li><li><p>数据链路层上的协议：MAC（网桥，交换机）</p></li><li><p>网络层对应的协议：IP，ICMP,  ARP,  RARP,  路由器</p></li><li><p>传输层对应的协议：TCP,  UDP</p></li><li><p>会话层对应的协议：NFS,  SQL,  NETBIOS</p></li><li><p>表示层对应的协议：JPEG,  MPEG</p></li><li><p>应用层对应的协议：FTP,  DNS,  TELNET,  SMTP,  HTTP,  WWW</p></li><li><p>ARP（地址解析协议）：实现IP地址转换为MAC地址。</p><p>​            实现的原理：</p><p>​                    1：首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。</p><p>​                   2：当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：<strong>源主机IP地址，源主机MAC地址，目的主机的IP地址</strong>。</p><p>​                   3：当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。</p><p>​                 4：源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p></li><li><p>TCP【传输控制协议】:是一种面向连接的，可靠的，基于字节流的传输层通信协议。</p></li><li><p>TCP协议如何来保证传输的可靠性：</p><p>​            &lt;1&gt;.数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；</p><p>​            &lt;2&gt;.对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；</p><p>​            &lt;3&gt;.丢弃重复数据：对于重复数据，能够丢弃重复数据；</p><p>​            &lt;4&gt;.应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</p><p>​            &lt;5&gt;.超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</p><p>​           &lt;6&gt;流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。</p></li><li><p>滑动窗口：窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p><p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p><p>具体如图<img src="/.io//Node\myblog\myblog\source_posts\计算机网络\滑动窗口.jpg" alt="滑动窗口"></p></li><li><p>TCP的拥塞控制实现：</p><p>​            &lt;1&gt;计算机网络中的带宽、交换结点中的缓存及处理机等都是网络的资源。**在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这种情况就叫做拥塞。拥塞控制就是 防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载.</p><p>​            &lt;2&gt;如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。拥塞控制起的作用如图：<img src="/.io//Node\myblog\myblog\source_posts\计算机网络\拥塞控制起的作用.jpg" alt="拥塞控制起的作用"></p><p>​            &lt;3&gt;注意，拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。拥塞控制的方法主要有以下四种： A、慢启动 B、拥塞避免 C、快重传 D、快恢复</p><p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p><p>为了便于讨论，做如下假设：</p><p>A、接收方有足够大的接收缓存，因此不会发生流量控制；</p><p>B、虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</p><p>​            &lt;4&gt;慢启动和拥塞避免：</p><p>​                        慢启动：<br>​                                        不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。<br>​                        拥塞避免：<br>​                                        拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。</p><p>​                                 具体如图：<img src="/.io//Node\myblog\myblog\source_posts\计算机网络\TCP拥塞窗口.jpg" alt="TCP拥塞窗口"></p><p>​                          发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p><p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p><p>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</p><p>​                 &lt;5&gt;快重传和快恢复：</p><p>​                               快重传：<br>​                                            快重传要求接收方在收到一个 <strong>失序的报文段</strong> 后就立即发出 <strong>重复确认</strong>（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。<br>​                                快恢复：<br>​                                            快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。</p><p>​                               具体如图：<img src="/.io//Node\myblog\myblog\source_posts\计算机网络\快重传示意图.jpg" alt="快重传示意图"></p><p>​                                在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</p><p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</p><p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p><p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p><p>​                         &lt;6&gt;TCP流量控制的流程图：<img src="/.io//Node\myblog\myblog\source_posts\计算机网络\TCP流量控制流程图.jpg" alt="TCP流量控制流程图"></p></li><li></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/03/14/Redis/"/>
      <url>2021/03/14/Redis/</url>
      
        <content type="html"><![CDATA[<p>1.Redis数据库的打开：进入Kali的/usr/redis的目录下，输入redis-server，启动服务端Redis。进入/usr/redis/redis.conf设置Redis相关配置</p><p>2.启动客户端Redis</p><p>​           &lt;1&gt;远程连接：redis-cli   -h   IP  -p  Port  -a  Password</p><p>​            &lt;2&gt;本地连接：redis-cli   -h  127.0.0.1  -p   6379  -a  Lhh….</p><p>​            </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/03/14/msf/"/>
      <url>2021/03/14/msf/</url>
      
        <content type="html"><![CDATA[<p>1.msf与shodan的结合【仅仅search shodan就可以】</p><p>2.msf搜索enable_rdp【RDP远程桌面协议，用来连接远程桌面；Win7的icbug用户名为icbug,ps为******】</p><p>3.利用msf获取另一台主机的权限后的一些命令;</p><p>​         getuid：查看用户权限</p><p>​         screenshot: 截图</p><p>​          webcam_stream:打开相机</p><p>​          upload  a.exe  C::上传病毒</p><p>​           execute -f   C:\a.exe:执行病毒文件</p><p>​          chcp 65001:获取主机权限后显示乱码</p><p>​          sessios:显示所有建立的session</p><p>​           session   -i  x :进入某个session会话</p><p>​          record_mic:打开对方的麦克风</p><p>​          web_chat:启动与目标计算机的视频聊天</p><p>​           webcam_snap:用于从目标设备获取照片</p><p>​            getsystem:获取系统管理员权限</p><p>​             background:进程隐藏到后台</p><p>4.选择脚本时应该优先选择excellent和great。</p><p>5.msf加载Nexpose插件的相关命令：</p><p>​               load nexpose:加载插件</p><p>​                nexpose_scan IP:扫描IP</p><p>​                db_hosts  -c  address :显示扫描漏洞的粗略信息</p><p>​                 db_vulns:显示漏洞的详细信息</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/03/14/Sqlmap/"/>
      <url>2021/03/14/Sqlmap/</url>
      
        <content type="html"><![CDATA[<p>1.参数：</p><p>​      -u 【指定url】</p><p>​     -dbms  【指定数据库的类型如MySQL，oracle】</p><p>​     -level  【级别越高，检测越全面，共5级】</p><p>​     -cookie  【使用cookie注入】</p><p>​      -dbs  【注入成功后查询有哪些数据库】</p><p>​       -D  test    -tables  【查询test数据库里面有哪些表】</p><p>​       -D test  -T  admin  -columns【查询test数据库种，admin表中有哪些字段】</p><p>​        -D test  -T  admin  -C  “username,password” -dump 【dump出字段username和password中的数据】</p><p>​         –batch  【不用每一次输入YES/NO】</p><p>​         –random-agent  【构造随机的user-agent】</p><p>​         –threads  【请求并发量】</p><p>​          -r  “C:\tools….txt”  【POST注入，xxx.txt为抓包的内容】</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/03/14/Nmap/"/>
      <url>2021/03/14/Nmap/</url>
      
        <content type="html"><![CDATA[<p>1.Nmap默认发送一个ARP的ping数据包来探测目标主机1~1000范围内开放的端口。</p><p>2.参数：  -vv【详细输出结果】</p><p>​                -p 【指定扫描端口a-b或者a,b,c】</p><p>​                -sP   【ping扫描，不发现端口和版本，仅仅检查是否存活主机】</p><p>​                -O   【输出操作系统信息】</p><p>​                -A  【万能命令】</p><p>​               -ip 【设置扫描IP】</p><p>​               -url 【设置网址】</p><p>​                -sS  【TCP,SYN扫描，匿名扫描，速度快；半开放扫描，只发送SYN，如果服务器恢复SYN,ACK，证明端口开放，不建立完整连接】</p><p>​                -sT 【TCP全连接扫描，耗时长，完成3次握手】</p><p>​               -sV 【探测开放端口的服务和版本信息】</p><p>​               -sA 【使用TCP的ACK进行扫描，穿越防火墙的规则集】</p><p>​                -sF 【使用FIN扫描，目标主机可能会有IDS和IPS系统的存在，防火墙可能过滤掉了SYN数据包，发送一个SYN标志的数据包不需要完成TCP握手】</p><p>​               -T 【取值0~5，级别越高扫描速度越快，也越容易被防火墙屏蔽掉】</p><p>​                -F 【快速扫描100个端口】</p><p>​                 -e 【使用指定的网卡发送数据包】</p><p>3.原理：默认情况下Nmap会发送4种不同类型的数据包来探测目标主机是否在线。只要收到其中一个包的回复就证明目标主机开启。</p><p>​               &lt;1&gt;  ICMP echo request</p><p>​               &lt;2&gt; a TCP SYN packet to port 443</p><p>​                &lt;3&gt;a TCP SYN packet to port 80</p><p>​                &lt;4&gt;an ICMP timestamp request</p><p>4.扫描结果分析：</p><p>​            open</p><p>​            closed</p><p>​             filtered</p><p>​             unfiltered 【数据可以到达，但是无法判断端口是开启或者关闭】</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/03/14/GitHack/"/>
      <url>2021/03/14/GitHack/</url>
      
        <content type="html"><![CDATA[<p>1.进入GitHack目录</p><p>2.输入 python  GitHack.py   网址/.git[使用GitHack脚本查看是否有git泄露]</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/03/14/crunch/"/>
      <url>2021/03/14/crunch/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/03/14/hydra/"/>
      <url>2021/03/14/hydra/</url>
      
        <content type="html"><![CDATA[<p>1.Hydra,俗称九头蛇，用来进行暴力破解。</p><p>2.使用介绍:  hydra  -L(与小写的l的区别是使用的是用户名本)  -l(使用单个的用户名)  -P(使用密码本)  -p(使用的单个密码)   -e nsr(n表示空密码登录，s表示使用pass和/登录，r表示反向登录)  -o(指定结果输出文件)   -f(找到正确的密码和用户名后终止破解)   -t(指定进程数)   -w(指定响应的最大等待时间)  -M(服务器列表IP列表)  -vV(v表示详细模式；-V表示每次登录成功的用户名和密码)    -I(大写的i表示忽略现有的恢复文件)</p><p>3.举例：</p><p>​      <FTP></FTP></p><p>hydra -I -f -l wang -P E:\桌面\hack\tools\Fuzz字典\密码字典\test.txt -o E:\桌面\hack\workspace\ftp-pwd-result.txt <a href="ftp://192.168.27.46/">ftp://192.168.27.46</a></p><p>​       <ssh></ssh></p><p>hydra -I -t 1 -l root -P E:\桌面\hack\tools\Fuzz字典\密码字典\test.txt -M E:\桌面\hack\workspace\22-output.txt -o E:\桌面\hack\workspace\ssh-pwd-result.txt ssh</p><p>​      <telnet></telnet></p><p>hydra -I -f -vV -l root -P E:\桌面\hack\tools\Fuzz字典\密码字典\test.txt  -o E:\桌面\hack\workspace\telnet-pwd-result.txt  telnet://192.168.27.32</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/03/14/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/"/>
      <url>2021/03/14/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/</url>
      
        <content type="html"><![CDATA[<p>1.后缀为.bak的文件是备份文件，打开时将.bak改为.txt即可。</p><p>2.sh文件权限不够：chmod +x  **.sh</p><p>3.Windows中进入cmd，输入systeminfo查看补丁信息。</p><p>4.JAWS为CCTV网络摄像头的关键【shodan搜索JAWS】</p><p>5.tomcat的用户名和密码都是tomcat</p><p>6.chmod 777 file1【类似于chmod a+rwx file1】【r=4,w=2,x=1】</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/03/14/kali%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>2021/03/14/kali%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p>1.切换到root用户：  su+密码</p><p>2.关闭系统：  init 0</p><p>3.重启系统：  reboot</p><p>4.显示工作目录： pwd</p><p>5.详细显示文件：ls -l</p><p>6.显示隐藏文件： ls -a</p><p>7.显示系统日期： date</p><p>8.删除文件：rm -f file1</p><p>9.删除目录： rmdir -rf dir1</p><p>10.创建目录： mkdir  dir1</p><p>11.重命名/移动一个目录：mv dir1 new-dir</p><p>12.复制一个文件： cp file1 file2</p><p>13.复制一个目录下的所有文件到当前目录：cp dir/* .</p><p>14.搜索文件：find /  -name file1</p><p>15.创建/删除一个新用户：useradd user1/userdel -r user1</p><p>16.解压/压缩zip文件： unzip filename.zip/zip filename.zip Dirname</p><p>17.解压/压缩gz文件： gunzip filename.gz/gzip filename</p><p>18.解压/压缩tar文件： tar xvf filename.tar/tar cvf filename.tar Dirname</p><p>19.解压/压缩rar文件： rar a filename.rar/rar e filename.rar</p><p>20.解压/压缩.tar.gz文件： tar zxvf filename.tar.gz/tar zcvf filename.tar.gz</p><p>21.提权：chmod u+w /etc/sudoer[u代表user,g代表group，o代表other，a代表所有][r,w,x分别代表读，写，执行][u对应的r,w,x为1，2，3；g对应的r,w,x,为4，5，6；o对应的r,w,x,为7，8，9][a+x可以写为+x]</p><p>22.比较两个文件的差异并输出：diff  -u  原文件1  源文件2  &gt; 目标文件 【将原文件1和原文件2对比的结果输入到目标文件】【“-”表示在原文件中，“+”表示在目标文件中；以空格开始的行表示在两个文件中都出现相同的内容】</p><p>23.查看文件: more 文件名</p><p>24.dpkg  -i  xxx.deb 【安装软件，其中xxx.deb为压缩包】</p><p>25.top  【类似于Win10的任务管理器】</p><p>26.df   【查看磁盘的使用率，其中的/dev/sdal显示的是内存的使用量】</p><p>27.apt-get clean 【清理系统垃圾】</p><p>28.touch  filename 【创建文件】</p><p>29.ip addr或者 sudo ifconfig：查看IP</p><p>30.sudo service mysql start:开启kali中的MySQL服务</p><p>31.systemctl start apache2:开启Kali中的apache服务。</p><p>32.sudo service nessusd start：启动Nessus。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
